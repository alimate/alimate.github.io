---
layout: post
title: "Thread-Local Allocation Buffers in JVM"
permalink: /blog/2019/6/21/tlab-jvm
comments: true
github: "https://github.com/alimate/alimate.github.io/blob/master/_posts/2018-3-9-do-not-use-cbc-with-same-iv.md"
excerpt: "Why the object allocation is so fast in JVM?..."
---
Let's take a look at this innocent and elegant masterpiece:
{% highlight java %}
Object foo = new Object();
{% endhighlight %}
*A solid weekend of hacking!* That's all we need to implement a run-time capable of performing such ***simple*** tasks! I mean, How hard can it be?
## Run-Time Data Areas in JVM
---
JVM defines various run-time data areas which a particular application can use during its execution. The *JVM Heap* is one of those areas
with two fundamental properties:
  - It's shared between all threads.
  - It's created when JVM starts.
  
So, all threads can potentially have access to each piece of the JVM heap. Suppose JVM is about to allocate an object for a particular thread. For some reason, it chose the depicted area as the allocation area for the new object *but the allocation has not been done, yet*:

<p style="text-align:center">
  <img src="/images/tlab-eden.png" alt="Eden for Objects!">
</p>

Still, a simple task unless the vicious OS decides to give this CPU slice to another thread! *Context switch enters the second thread* with a demand for new object allocation. What if the JVM chooses the same area for this new allocation, too? Same story if we are bad luck enough experiencing two truly parallel object allocations!

Is there any way to ***synchronize*** multiple threads regarding how they can access the JVM heap? Again, a simple solution: *Lock, lock and more lock!*.

## A Poor Man's Allocation
---
Since objects are allocated directly in a shared space, *the Eden Space*, we need some sort of synchronization to avoid allocating two objects in the same pointer space.

The first solution comes to mind is to use locks! That is, JVM should grant exclusive access to a thread for a particular region of heap *every time it's going allocate an object*, ***every single time***. 

*Imagine a run-time that its threads are always acquiring and releasing some locks, even if there were no contention at all*. 

## Shared Mutable State
---
As with many other thread-safety challenges in multi-threaded environments, we should somehow manage the ***mutable states shared*** between multiple threads. If we can't do something about those states, then we may not find a better solution than locks!

But if we could find a way to eliminate one of those three key properties, then there would be no need for a synchronization: 
 - When we're talking about the JVM heap, the **state** is the pointer space we're going to use for allocations. *Unfortunately, We need this state*.
 - In order to be able to allocate objects, we need to **mutate** the pointer space, *so we can't do anything about the mutation, either*.

*Do we need to allocate new objects in a shared pointer space?*

## Thread-Local Allocation Buffers
----
Although a few new GC algorithms are not strictly following the generational idea, let's us to have the luxury of visualizing the JVM heap as following:

<p style="text-align:center">
  <img src="/images/tlab-gens.png" alt="Weak Generational Hypothesis!">
</p>

When the insane-mode is off, all new object allocations should happen in the *Eden Space*. Dedicating a sub-region of the whole heap for new allocation is one of the reasons that the new allocations are so fast in JVM. 

As it turns out, for even more faster allocations, *JVM divides the eden space into a few more sub-regions, each dedicated to a particular thread*. Each of those dedicates regions are called *Thread-Local Allocation Buffers* or *TLAB* for short.

<p style="text-align:center">
  <img src="/images/tlab-regions.png" alt="Thread-Local Allocation Buffers">
</p>

When allocating a new object, JVM would allocate that object in the TLAB dedicated to the originating thread. **Since each thread can only write to its own TLAB, then there is no need for synchronization**. TLABs are enabled by default but if you're insane enough, you can always disable it using the `-XX:-UseTLAB` tuning falg.

### TLAB Sizing
TODO...
